---
title: Component System - 함수형 컴포넌트의 혁신
description: AdorableCSS v2의 문자열 기반 함수형 컴포넌트 시스템과 shadcn/ui 스타일 구현
order: 33
category: Components
---

# Component System: 함수형 컴포넌트의 혁신

AdorableCSS v2의 **Component System**은 CSS 프레임워크 역사상 가장 혁신적인 컴포넌트 아키텍처입니다. **문자열 기반 함수형 생성**, **하이브리드 CSS 출력**, 그리고 **shadcn/ui 스타일 디자인**을 결합하여 완전히 새로운 개발자 경험을 제공합니다.

## 🏗️ 컴포넌트 아키텍처 개요

### 3-Tier 계층 구조

AdorableCSS v2는 컴포넌트를 **3단계 계층**으로 구성했습니다:

```
src/components/
├── primitives/     # 🔹 기본 UI 빌딩 블록 (shadcn/ui 스타일)
├── patterns/       # 🔹 복합 레이아웃 패턴 (Apple/Editorial 스타일)  
└── features/       # 🔹 고급 효과와 인터랙션 (모던 CSS 활용)
```

### 함수형 컴포넌트 생성

```html
<!-- 전통적인 CSS 클래스 조합 -->
<button class="btn btn-primary btn-lg">Old Way</button>

<!-- AdorableCSS v2 함수형 생성 -->
<button class="btn(primary/lg)">New Way</button>
```

**단 하나의 함수 호출**로 **무한한 변형**을 생성할 수 있습니다.

## 🔹 Primitives: shadcn/ui 스타일 기본 컴포넌트

### Button: 6가지 Semantic Variant

```html
<!-- 기본 사용법: btn(variant/size) -->
<button class="btn()">Default Button</button>
<button class="btn(primary)">Primary Action</button>
<button class="btn(secondary/lg)">Large Secondary</button>
<button class="btn(destructive/sm)">Small Destructive</button>
<button class="btn(outline)">Outline Style</button>
<button class="btn(ghost)">Ghost Button</button>
<button class="btn(link)">Link Style</button>

<!-- 아이콘 전용 버튼 -->
<button class="icon-btn()">📧</button>
<button class="icon-btn(destructive)">🗑️</button>
```

#### 내부 구현: 하이브리드 아키텍처

```typescript
// button.ts - 문자열 + CSS 객체 혼합
export const btn: StringRuleHandler = (args = ''): (string | CSSRule)[] => {
  const [variant = 'default', size = 'default'] = args.split('/');
  
  // 1. AdorableCSS 베이스 클래스들
  const baseClasses = 'inline-flex items(center) justify(center) gap(8) r(md) font(sm) bold transition-all';
  
  // 2. 크기별 클래스
  const sizeClasses = {
    sm: 'h(36) px(12) text(sm)',
    default: 'h(40) px(16)',
    lg: 'h(44) px(32)',
    icon: 'size(40)'
  };
  
  // 3. Raw CSS 객체 (복잡한 스타일과 상태)
  const variantStyles: Record<string, CSSRule> = {
    primary: {
      'background': 'var(--gray-900)',
      'color': 'var(--gray-50)',
      '&:hover': { 'background': 'var(--gray-800)' },
      '&:focus-visible': { 
        'outline': '2px solid var(--gray-950)',
        'outline-offset': '2px'
      }
    },
    secondary: {
      'background': 'var(--gray-100)',
      'color': 'var(--gray-900)',
      '&:hover': { 'background': 'var(--gray-200)' }
    },
    destructive: {
      'background': 'var(--red-600)',
      'color': 'white',
      '&:hover': { 'background': 'var(--red-700)' }
    }
  };
  
  // 4. 하이브리드 반환: [AdorableCSS클래스들, CSS객체]
  return [
    `${baseClasses} ${sizeClasses[size]}`,
    variantStyles[variant] || variantStyles.default
  ];
};
```

### Card: 8가지 시각적 변형

```html
<!-- 기본 카드 시리즈 -->
<div class="card()">Basic white card</div>
<div class="card(outlined)">Outlined border</div>
<div class="card(ghost)">Subtle background</div>
<div class="card(elevated)">Strong shadow</div>

<!-- 인터랙티브 카드 -->
<div class="card(interactive)">Clickable with hover</div>
<div class="card(interactive/lg)">Large interactive</div>

<!-- 고급 시각적 효과 -->
<div class="card(glass)">Glass morphism</div>
<div class="card(gradient)">Gradient border</div>
```

#### Card 내부 구현의 정교함

```typescript
// card.ts - 8가지 변형의 체계적 관리
export const card: StringRuleHandler = (args = ''): (string | CSSRule)[] => {
  const [variant = 'default', size = 'default'] = args.split('/');
  
  // 베이스: AdorableCSS 클래스 조합
  const baseClasses = 'bg(white) r(lg) p(24)';
  
  const variantDefinitions: Record<string, (string | CSSRule)[]> = {
    default: [
      'shadow(sm)',
      { 'border': '1px solid var(--gray-200)' }
    ],
    
    glass: [
      'bg(white.9) border(white.2)',
      { 
        'backdrop-filter': 'blur(10px) saturate(1.2)',
        'border': '1px solid rgba(255,255,255,0.2)'
      }
    ],
    
    interactive: [
      'shadow(sm) cursor(pointer) transition-all',
      {
        '&:hover': {
          'box-shadow': 'var(--shadow-md)',
          'transform': 'translateY(-2px)'
        },
        '&:active': {
          'transform': 'translateY(0)'
        }
      }
    ],
    
    gradient: [
      'bg(white) p(24)',
      {
        'background': `
          linear-gradient(white, white) padding-box,
          linear-gradient(135deg, var(--blue-500), var(--purple-500)) border-box
        `,
        'border': '2px solid transparent'
      }
    ]
  };
  
  return [baseClasses, ...variantDefinitions[variant]];
};
```

### Heading: 타이포그래피 + 그래디언트

```html
<!-- 표준 계층구조 -->
<h1 class="heading(h1)">Page Title</h1>
<h2 class="heading(h2)">Section Title</h2>
<h3 class="heading(h3)">Subsection</h3>

<!-- 특수 용도 제목 -->
<h1 class="heading(hero)">Hero Landing Title</h1>
<h1 class="heading(display)">Display Typography</h1>
<h2 class="heading(page)">Page Header</h2>

<!-- 그래디언트 텍스트 -->
<h1 class="heading(h1/gradient)">Gradient Title</h1>
<h2 class="heading(h2/gradient-brand)">Brand Gradient</h2>
```

### Badge: Semantic Color System

```html
<!-- Semantic 배지 -->
<span class="badge()">Default</span>
<span class="badge(primary)">Primary</span>
<span class="badge(success)">Success</span>
<span class="badge(warning)">Warning</span>
<span class="badge(destructive)">Error</span>

<!-- 크기 변형 -->
<span class="badge(primary/sm)">Small Primary</span>
<span class="badge(success/lg)">Large Success</span>
```

### Input: shadcn 스타일 폼 요소

```html
<!-- 기본 인풋 -->
<input class="input()" placeholder="Enter text..." />
<input class="input(sm)" placeholder="Small input" />
<input class="input(lg)" placeholder="Large input" />

<!-- 특수 인풋 타입 -->
<input class="input(file)" type="file" />
<input class="input(search)" type="search" placeholder="Search..." />

<!-- 상태 변형 -->
<input class="input(error)" placeholder="Error state" />
<input class="input(success)" placeholder="Success state" />
```

## 🔹 Patterns: Apple 스타일 고급 레이아웃

### Container: Apple 영감의 반응형 시스템

```html
<!-- 기본 컨테이너 -->
<div class="container()">
  Basic responsive container
</div>

<!-- 크기별 컨테이너 -->
<div class="container(sm)">Narrow container</div>
<div class="container(lg)">Wide container</div>
<div class="container(xl)">Extra wide</div>

<!-- Safe area 지원 -->
<div class="container(safe)">
  Mobile safe area support
</div>

<!-- Bleed 레이아웃 -->
<div class="container(bleed)">
  Full-width bleed container
</div>
```

#### Container 내부: 정교한 반응형 로직

```typescript
// container.ts - Apple 스타일 컨테이너
export const container: StringRuleHandler = (args = ''): (string | CSSRule)[] => {
  const variant = args || 'default';
  
  const baseClasses = 'mx(auto) px(16)';
  
  const containerDefinitions: Record<string, (string | CSSRule)[]> = {
    default: [
      'max-w(1200)',
      {
        '@media (min-width: 640px)': { 'padding-left': '24px', 'padding-right': '24px' },
        '@media (min-width: 1024px)': { 'padding-left': '32px', 'padding-right': '32px' }
      }
    ],
    
    safe: [
      'max-w(1200)',
      {
        'padding-left': 'max(16px, env(safe-area-inset-left))',
        'padding-right': 'max(16px, env(safe-area-inset-right))',
        'padding-top': 'env(safe-area-inset-top)',
        'padding-bottom': 'env(safe-area-inset-bottom)'
      }
    ],
    
    bleed: [
      'w(full)',
      {
        'margin-left': 'calc(-50vw + 50%)',
        'margin-right': 'calc(-50vw + 50%)',
        'max-width': 'none'
      }
    ]
  };
  
  return [baseClasses, ...containerDefinitions[variant]];
};
```

### Prose: 500줄의 정교한 타이포그래피

```html
<!-- 기본 산문 스타일링 -->
<article class="prose()">
  <h1>Article Title</h1>
  <p>Article content with perfect typography...</p>
  <blockquote>Elegant blockquotes</blockquote>
  <ul><li>List items</li></ul>
</article>

<!-- 크기 변형 -->
<article class="prose(sm)">Smaller text</article>
<article class="prose(lg)">Larger text</article>
<article class="prose(xl)">Display size</article>

<!-- 스타일 변형 -->
<article class="prose(gray)">Gray color scheme</article>
<article class="prose(invert)">Dark mode optimized</article>
```

#### Prose 구현: Editorial 품질 타이포그래피

```typescript
// prose.ts - 500+ 라인의 정교한 타이포그래피
export const prose: StringRuleHandler = (args = ''): (string | CSSRule)[] => {
  const [size = 'default', variant = 'default'] = args.split('/');
  
  const baseClasses = 'max-w(65ch) leading(relaxed)';
  
  return [
    baseClasses,
    {
      // 황금비율 기반 타이포그래피 스케일
      '& h1': {
        'font-size': 'clamp(1.875rem, 4vw, 2.25rem)',
        'line-height': '1.1',
        'font-weight': '800',
        'letter-spacing': '-0.025em',
        'margin-top': '0',
        'margin-bottom': '1rem'
      },
      
      '& h2': {
        'font-size': 'clamp(1.5rem, 3vw, 1.875rem)', 
        'line-height': '1.2',
        'font-weight': '700',
        'margin-top': '2rem',
        'margin-bottom': '1rem'
      },
      
      // 매거진 스타일 blockquote
      '& blockquote': {
        'font-size': '1.125rem',
        'font-style': 'italic',
        'line-height': '1.6',
        'margin': '2rem 0',
        'padding-left': '1.5rem',
        'border-left': '4px solid var(--gray-200)',
        'color': 'var(--gray-600)',
        
        // 큰 따옴표 마크
        '&::before': {
          'content': '"\\201C"',
          'font-size': '3rem',
          'color': 'var(--gray-300)',
          'line-height': '1',
          'float': 'left',
          'margin-right': '0.5rem',
          'margin-top': '-0.5rem'
        }
      },
      
      // 고급 테이블 스타일링
      '& table': {
        'width': '100%',
        'border-collapse': 'collapse',
        'margin': '2rem 0',
        'font-size': '0.875rem',
        
        '& th': {
          'background': 'var(--gray-50)',
          'font-weight': '600',
          'text-align': 'left',
          'padding': '0.75rem',
          'border-bottom': '2px solid var(--gray-200)'
        },
        
        '& td': {
          'padding': '0.75rem',
          'border-bottom': '1px solid var(--gray-200)'
        }
      },
      
      // OpenType 기능 활용
      'font-feature-settings': '"kern" 1, "liga" 1, "calt" 1',
      'font-variant-ligatures': 'common-ligatures contextual',
      'font-variant-numeric': 'oldstyle-nums proportional-nums'
    }
  ];
};
```

## 🔹 Features: 모던 CSS 고급 효과

### Glass: Glass Morphism 효과

```html
<!-- 기본 글래스 효과 -->
<div class="glass()">Basic glass effect</div>

<!-- 변형들 -->
<div class="glass(card)">Glass card style</div>
<div class="glass(nav)">Navigation glass</div>
<div class="glass(dark)">Dark mode glass</div>

<!-- 강도 조절 -->
<div class="glass(light)">Light glass</div>
<div class="glass(heavy)">Heavy glass</div>
```

#### Glass 구현: 정교한 백드롭 필터

```typescript
// glass.ts - Glass morphism 구현
export const glass: StringRuleHandler = (args = ''): (string | CSSRule)[] => {
  const variant = args || 'default';
  
  const glassDefinitions: Record<string, (string | CSSRule)[]> = {
    default: [
      'bg(white.1) border(white.2)',
      {
        'backdrop-filter': 'blur(10px) saturate(1.5)',
        'border': '1px solid rgba(255, 255, 255, 0.2)',
        'box-shadow': '0 8px 32px rgba(0, 0, 0, 0.1)'
      }
    ],
    
    card: [
      'bg(white.05) r(xl) p(24)',
      {
        'backdrop-filter': 'blur(16px) saturate(1.8) contrast(1.2)',
        'border': '1px solid rgba(255, 255, 255, 0.1)',
        'box-shadow': `
          0 8px 32px rgba(0, 0, 0, 0.12),
          inset 0 1px 0 rgba(255, 255, 255, 0.2)
        `
      }
    ],
    
    dark: [
      'bg(black.1) border(white.1)',
      {
        'backdrop-filter': 'blur(12px) saturate(1.3)',
        'border': '1px solid rgba(255, 255, 255, 0.1)',
        'box-shadow': '0 8px 32px rgba(0, 0, 0, 0.3)'
      }
    ]
  };
  
  return glassDefinitions[variant];
};
```

### Interactive: 인터랙션 효과 시스템

```html
<!-- 기본 인터랙션 -->
<div class="interactive()">Hover and click effects</div>

<!-- 강도별 인터랙션 -->
<div class="interactive(subtle)">Subtle interaction</div>
<div class="interactive(moderate)">Moderate lift</div>
<div class="interactive(strong)">Strong response</div>
<div class="interactive(dramatic)">Dramatic effect</div>

<!-- 3D 인터랙션 -->
<div class="interactive(3d)">3D transform effects</div>
```

### Glow: 네온/글로우 효과

```html
<!-- 색상별 글로우 -->
<div class="glow(blue)">Blue glow effect</div>
<div class="glow(purple)">Purple glow</div>
<div class="glow(green)">Success glow</div>
<div class="glow(red)">Error glow</div>

<!-- 강도 조절 -->
<div class="glow(blue/soft)">Soft blue glow</div>
<div class="glow(purple/intense)">Intense purple glow</div>
```

## 🔧 하이브리드 시스템의 혁신

### 문자열 + CSS 객체 완벽 조합

AdorableCSS v2 컴포넌트의 핵심은 **두 시스템의 완벽한 결합**입니다:

```typescript
// StringRuleHandler 타입 정의
export type StringRuleHandler = (args?: string) => string | (string | CSSRule)[];

// 실제 반환 예시
return [
  'inline-flex items(center) justify(center) gap(8)',  // AdorableCSS 클래스
  {
    'background': 'var(--gray-900)',                   // Raw CSS 객체
    'transition': 'all 0.2s cubic-bezier(0.4,0,0.2,1)',
    '&:hover': { 'background': 'var(--gray-800)' },
    '&:focus-visible': { 
      'outline': '2px solid var(--ring)',
      'outline-offset': '2px' 
    }
  }
];
```

### 장점: 두 세계의 장점

**AdorableCSS 클래스 부분**:
- ✅ 간결하고 읽기 쉬운 문법
- ✅ 토큰 시스템과 자동 연결
- ✅ 반응형과 상태 수식어 지원

**Raw CSS 객체 부분**:
- ✅ 복잡한 스타일과 애니메이션
- ✅ 가상 요소와 고급 선택자
- ✅ 브라우저별 벤더 프리픽스

## 🎯 shadcn/ui와의 차별화

| 측면 | shadcn/ui | AdorableCSS v2 |
|------|-----------|----------------|
| **컴포넌트 생성** | 템플릿 복사/붙여넣기 | 함수형 동적 생성 |
| **변형 관리** | 수동 클래스 조합 | 자동 variant 시스템 |
| **커스터마이징** | CSS 변수 수정 | 프로그래매틱 확장 |
| **타입 안전성** | props 인터페이스 | 문자열 파싱 |
| **번들 크기** | 사용한 컴포넌트만 | 사용한 variant만 |
| **디자인 시스템** | Tailwind 기반 | OKLCH + 토큰 기반 |

### AdorableCSS v2의 고유 장점

**1. 무한 변형 조합**
```html
<!-- shadcn/ui 방식 -->
<Button variant="secondary" size="lg" className="custom-class">

<!-- AdorableCSS v2 방식 -->
<button class="btn(secondary/lg) custom-utility">
```

**2. 동적 컴포넌트 생성**
```typescript
// 런타임에 새로운 변형 생성 가능
const customCard = card('glass/xl') + ' special-effect';
```

**3. Figma 워크플로우 통합**
```html
<!-- Figma에서 "Glass card, large, with glow" -->
<div class="card(glass/lg) glow(blue/soft)">
  Figma 디자인 → 직접 코드 변환
</div>
```

## 🚀 고급 사용 패턴

### 컴포넌트 조합과 레이어링

```html
<!-- 복합 컴포넌트 구성 -->
<div class="card(glass/lg) interactive(moderate)">
  <div class="vbox gap(16) p(24)">
    <h2 class="heading(h2/gradient)">Interactive Glass Card</h2>
    <p class="prose() c(gray-600)">
      Enhanced typography with glass morphism
    </p>
    <button class="btn(primary) glow(blue/soft)">
      Glowing Action
    </button>
  </div>
</div>

<!-- 반응형 컴포넌트 -->
<div class="card() md:card(glass) lg:card(glass/xl)">
  Progressive enhancement
</div>
```

### 테마 시스템과 통합

```html
<!-- 라이트/다크 테마 대응 -->
<div class="card() dark:card(dark) glass(light) dark:glass(dark)">
  Theme-aware glass card
</div>

<!-- 브랜드 변형 -->
<button class="btn(brand) glow(brand/soft)">
  Brand themed button
</button>
```

## 📊 성능과 최적화

### 사용 기반 CSS 생성

```typescript
// 사용된 컴포넌트 variant만 CSS 생성
btn(primary)      // ✅ primary variant CSS 생성
btn(secondary)    // ✅ secondary variant CSS 생성
// destructive variant는 CSS에 포함되지 않음
```

### 점진적 향상

```html
<!-- 기본 스타일부터 고급 효과까지 -->
<div class="card()">                    <!-- 기본 카드 -->
<div class="card(glass)">              <!-- + Glass morphism -->
<div class="card(glass) interactive()"> <!-- + 인터랙션 -->
<div class="card(glass) interactive() glow(blue)"> <!-- + 글로우 -->
```

## 📋 결론: 컴포넌트 시스템의 새로운 패러다임

AdorableCSS v2 Component System은:

- ✅ **함수형 생성**: `btn(variant/size)` 무한 조합
- ✅ **하이브리드 아키텍처**: 문자열 + CSS 객체 완벽 결합
- ✅ **shadcn/ui 품질**: 현대적 디자인과 접근성
- ✅ **3-Tier 구조**: Primitives → Patterns → Features
- ✅ **Figma 통합**: 디자인 → 코드 직접 변환

이제 컴포넌트는 더 이상 **정적인 템플릿**이 아닌, **동적으로 생성되는 디자인 함수**입니다. `card(glass/lg)`, `btn(primary)`, `heading(hero/gradient)` 같은 직관적 문법으로 **무한한 가능성을 가진 컴포넌트**를 만들 수 있습니다.

**Primitives + Patterns + Features = 완벽한 디자인 시스템**

이것이 AdorableCSS v2가 제안하는 컴포넌트의 미래입니다.