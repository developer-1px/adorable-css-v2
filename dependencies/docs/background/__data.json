{"type":"data","nodes":[null,null,{"type":"data","data":[{"title":1,"description":2,"code":3,"frontmatter":4,"css":5},"Background","디자인과 코드 사이의 영원한 숙제","\u003Ch1>왜 디자이너와 개발자는 다른 언어를 사용하는가\u003C/h1>\n\u003Ch2>같은 화면, 다른 언어\u003C/h2>\n\u003Cp>디자이너가 &quot;가운데 정렬&quot;이라고 말할 때, 개발자는 어떤 코드를 떠올릴까요?\u003C/p>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-css\">\u003Cspan class=\"hljs-comment\">/* 방법 1 */\u003C/span> \u003Cspan class=\"hljs-attribute\">text-align\u003C/span>: center;\n\u003Cspan class=\"hljs-comment\">/* 방법 2 */\u003C/span> \u003Cspan class=\"hljs-attribute\">margin\u003C/span>: \u003Cspan class=\"hljs-number\">0\u003C/span> auto;\n\u003Cspan class=\"hljs-comment\">/* 방법 3 */\u003C/span> \u003Cspan class=\"hljs-attribute\">display\u003C/span>: flex; \u003Cspan class=\"hljs-attribute\">justify-content\u003C/span>: center; \u003Cspan class=\"hljs-attribute\">align-items\u003C/span>: center;\n\u003Cspan class=\"hljs-comment\">/* 방법 4 */\u003C/span> \u003Cspan class=\"hljs-attribute\">position\u003C/span>: absolute; \u003Cspan class=\"hljs-attribute\">left\u003C/span>: \u003Cspan class=\"hljs-number\">50%\u003C/span>; \u003Cspan class=\"hljs-attribute\">transform\u003C/span>: \u003Cspan class=\"hljs-built_in\">translateX\u003C/span>(-\u003Cspan class=\"hljs-number\">50%\u003C/span>);\n\u003Cspan class=\"hljs-comment\">/* 방법 5 */\u003C/span> \u003Cspan class=\"hljs-attribute\">display\u003C/span>: grid; \u003Cspan class=\"hljs-attribute\">place-items\u003C/span>: center;\n\u003C/code>\u003C/pre>\n\u003Cp>&quot;가운데 정렬&quot;이라는 단순한 요구사항에 최소 5가지 구현 방법이 존재합니다. 각각은 서로 다른 상황에서 사용되고, 다른 부작용을 가지며, 다른 브라우저 지원을 필요로 합니다.\u003C/p>\n\u003Cp>이것이 문제의 핵심입니다. \u003Cstrong>디자이너와 개발자는 같은 결과물을 만들면서도 완전히 다른 언어를 사용합니다.\u003C/strong>\u003C/p>\n\u003Ch2>번역이 필요한 이유\u003C/h2>\n\u003Ch3>Figma는 “무엇을” 묻고, CSS는 &quot;어떻게&quot;를 답한다\u003C/h3>\n\u003Cp>Figma에서 버튼을 만들 때:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>“이것은 Primary Button이다”\u003C/li>\n\u003Cli>“Medium 크기다”\u003C/li>\n\u003Cli>“Default 상태다”\u003C/li>\n\u003C/ul>\n\u003Cp>CSS로 같은 버튼을 만들 때:\u003C/p>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-css\">\u003Cspan class=\"hljs-selector-class\">.button\u003C/span> {\n  \u003Cspan class=\"hljs-attribute\">display\u003C/span>: inline-flex;\n  \u003Cspan class=\"hljs-attribute\">align-items\u003C/span>: center;\n  \u003Cspan class=\"hljs-attribute\">justify-content\u003C/span>: center;\n  \u003Cspan class=\"hljs-attribute\">padding\u003C/span>: \u003Cspan class=\"hljs-number\">8px\u003C/span> \u003Cspan class=\"hljs-number\">16px\u003C/span>;\n  \u003Cspan class=\"hljs-attribute\">background-color\u003C/span>: \u003Cspan class=\"hljs-number\">#0066cc\u003C/span>;\n  \u003Cspan class=\"hljs-attribute\">color\u003C/span>: white;\n  \u003Cspan class=\"hljs-attribute\">border\u003C/span>: none;\n  \u003Cspan class=\"hljs-attribute\">border-radius\u003C/span>: \u003Cspan class=\"hljs-number\">4px\u003C/span>;\n  \u003Cspan class=\"hljs-attribute\">font-size\u003C/span>: \u003Cspan class=\"hljs-number\">14px\u003C/span>;\n  \u003Cspan class=\"hljs-attribute\">font-weight\u003C/span>: \u003Cspan class=\"hljs-number\">500\u003C/span>;\n  \u003Cspan class=\"hljs-attribute\">cursor\u003C/span>: pointer;\n  \u003Cspan class=\"hljs-comment\">/* ... 더 많은 속성들 */\u003C/span>\n}\n\u003C/code>\u003C/pre>\n\u003Cp>Figma는 의도를 표현하고, CSS는 구현 방법을 나열합니다. 이 간극에서 수많은 해석의 여지가 생기고, 그 결과 &quot;디자인과 다르다&quot;는 피드백이 끊이지 않습니다.\u003C/p>\n\u003Ch3>공통 언어의 부재\u003C/h3>\n\u003Cp>실제 프로젝트에서 자주 발생하는 대화:\u003C/p>\n\u003Cblockquote class=\"border-l(4/gray-300) pl(lg) my(xl) italic c(gray-700)\">\u003Cp>디자이너: “여기 Auto Layout으로 만들었는데 간격이 이상해요”\u003Cbr>\n개발자: “flex-direction이 row인데 gap을 16px로 했어요”\u003Cbr>\n디자이너: “…무슨 말인지 모르겠어요”\u003C/p>\n\u003C/blockquote>\n\u003Cp>서로 다른 용어를 사용하기 때문에 같은 것을 두고도 소통이 어렵습니다. 더 큰 문제는 이런 번역 과정에서 원래 의도가 왜곡된다는 것입니다.\u003C/p>\n\u003Ch2>역사가 만든 간극\u003C/h2>\n\u003Ch3>CSS: 문서를 위해 태어나다\u003C/h3>\n\u003Cp>CSS가 처음 만들어진 1996년, 웹의 주요 콘텐츠는 연구 논문과 기술 문서였습니다. 자연스럽게 CSS는 &quot;문서를 꾸미는 도구&quot;로 설계되었고, 이는 오늘날까지 CSS의 기본 철학에 영향을 미칩니다.\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>\u003Cstrong>Normal Flow\u003C/strong>: 위에서 아래로 흐르는 문서\u003C/li>\n\u003Cli>\u003Cstrong>Box Model\u003C/strong>: 각 요소는 사각형 상자\u003C/li>\n\u003Cli>\u003Cstrong>Cascade\u003C/strong>: 스타일이 폭포처럼 상속\u003C/li>\n\u003C/ul>\n\u003Cp>이런 개념들은 논문을 레이아웃하기에는 완벽했지만, 복잡한 애플리케이션 UI를 만들기에는 부족했습니다.\u003C/p>\n\u003Ch3>Figma: 인터페이스를 위해 태어나다\u003C/h3>\n\u003Cp>20년 후인 2016년, Figma는 완전히 다른 환경에서 탄생했습니다. 이미 웹은 애플리케이션 플랫폼이 되어 있었고, 디자이너들은 복잡한 인터페이스를 만들고 있었습니다.\u003C/p>\n\u003Cp>Figma는 처음부터 &quot;인터페이스 디자인 도구&quot;로 만들어졌기에:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>\u003Cstrong>Frame\u003C/strong>: 독립적인 컨테이너\u003C/li>\n\u003Cli>\u003Cstrong>Constraints\u003C/strong>: 반응형 동작 정의\u003C/li>\n\u003Cli>\u003Cstrong>Auto Layout\u003C/strong>: 동적 레이아웃 시스템\u003C/li>\n\u003C/ul>\n\u003Cp>이 개념들은 CSS보다 훨씬 직관적으로 UI를 표현할 수 있게 해주었습니다.\u003C/p>\n\u003Ch2>진짜 문제: 추상화 레벨의 불일치\u003C/h2>\n\u003Ch3>높은 수준의 추상화 vs 낮은 수준의 구현\u003C/h3>\n\u003Cp>Figma의 &quot;Auto Layout&quot;을 생각해보세요. 단 하나의 개념으로:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>방향 설정 (가로/세로)\u003C/li>\n\u003Cli>간격 조절\u003C/li>\n\u003Cli>패딩 적용\u003C/li>\n\u003Cli>정렬 방식 선택\u003C/li>\n\u003C/ul>\n\u003Cp>이 모든 것을 해결합니다.\u003C/p>\n\u003Cp>반면 CSS에서는:\u003C/p>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-css\">\u003Cspan class=\"hljs-attribute\">display\u003C/span>: flex;\n\u003Cspan class=\"hljs-attribute\">flex-direction\u003C/span>: row;\n\u003Cspan class=\"hljs-attribute\">gap\u003C/span>: \u003Cspan class=\"hljs-number\">16px\u003C/span>;\n\u003Cspan class=\"hljs-attribute\">padding\u003C/span>: \u003Cspan class=\"hljs-number\">24px\u003C/span>;\n\u003Cspan class=\"hljs-attribute\">align-items\u003C/span>: center;\n\u003Cspan class=\"hljs-attribute\">justify-content\u003C/span>: space-between;\n\u003C/code>\u003C/pre>\n\u003Cp>6개의 속성을 개별적으로 이해하고 조합해야 합니다.\u003C/p>\n\u003Ch3>맥락의 소실\u003C/h3>\n\u003Cp>Figma에서 &quot;Fill Container&quot;는 명확합니다. 부모 크기에 맞춰 늘어나는 것이죠.\u003C/p>\n\u003Cp>하지만 CSS의 \u003Ccode class=\"bg(gray-50) c(purple-700) px(xs) py(0.5) r(sm) border(1/gray-200) font(mono) text(sm)\">width: 100%\u003C/code>는 상황에 따라 다르게 동작합니다:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>일반 요소: 부모의 content 영역만큼\u003C/li>\n\u003Cli>Flex 아이템: flex-grow가 우선할 수도\u003C/li>\n\u003Cli>Absolute 요소: positioned 부모 기준\u003C/li>\n\u003Cli>Table 셀: 복잡한 계산 알고리즘\u003C/li>\n\u003C/ul>\n\u003Cp>이런 복잡성 때문에 의도한 대로 구현되지 않는 경우가 빈번합니다.\u003C/p>\n\u003Ch2>현장의 목소리\u003C/h2>\n\u003Ch3>Spotify의 경험 (2022)\u003C/h3>\n\u003Cp>Spotify 디자인 시스템 팀의 발표에 따르면:\u003C/p>\n\u003Cblockquote class=\"border-l(4/gray-300) pl(lg) my(xl) italic c(gray-700)\">\u003Cp>“Figma 토큰과 코드 토큰의 불일치로 인한 버그가 전체 UI 버그의 43%를 차지했다”\u003C/p>\n\u003C/blockquote>\n\u003Cp>단순히 이름이 달라서가 아니라, 같은 &quot;Primary Blue&quot;가 Figma와 코드에서 미묘하게 다른 값을 가지고 있었던 것입니다.\u003C/p>\n\u003Ch3>Airbnb의 고민 (2021)\u003C/h3>\n\u003Cblockquote class=\"border-l(4/gray-300) pl(lg) my(xl) italic c(gray-700)\">\u003Cp>“반응형 디자인을 구현하는 데 전체 프론트엔드 개발 시간의 30%가 소요된다”\u003C/p>\n\u003C/blockquote>\n\u003Cp>Figma에서는 &quot;태블릿에서 2열&quot;이라고 표현하지만, 코드에서는 정확한 브레이크포인트, 간격, 정렬 방식을 모두 명시해야 합니다.\u003C/p>\n\u003Ch2>해결의 실마리: 공통 언어 만들기\u003C/h2>\n\u003Ch3>번역이 아닌 직접 대화\u003C/h3>\n\u003Cp>문제가 번역에서 발생한다면, 번역을 없애면 됩니다.\u003C/p>\n\u003Cp>AdorableCSS의 접근:\u003C/p>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: Horizontal Auto Layout, gap 16px, padding 24px --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;hbox gap(16) p(24)&quot;\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>CSS 용어를 배우는 대신, Figma 용어를 그대로 사용합니다.\u003C/p>\n\u003Ch3>의도를 코드로\u003C/h3>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- 전통적 CSS: HOW를 나열 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;display-flex flex-direction-row align-items-center justify-content-space-between&quot;\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- AdorableCSS: WHAT을 표현 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;hbox(between)&quot;\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>&quot;어떻게 구현할 것인가&quot;가 아닌 &quot;무엇을 만들 것인가&quot;를 코드로 표현합니다.\u003C/p>\n\u003Ch3>실제 효과\u003C/h3>\n\u003Cp>한 스타트업의 사례:\u003C/p>\n\u003Cblockquote class=\"border-l(4/gray-300) pl(lg) my(xl) italic c(gray-700)\">\u003Cp>“AdorableCSS 도입 3개월 후, 디자인 QA 시간이 80% 감소했습니다.\u003Cbr>\n가장 큰 변화는 디자이너가 개발자에게 'hbox에 gap 20 주세요’라고\u003Cbr>\n직접 코드를 언급하기 시작했다는 것입니다.”\u003C/p>\n\u003C/blockquote>\n\u003Ch2>더 나은 미래를 향해\u003C/h2>\n\u003Ch3>도구의 진화\u003C/h3>\n\u003Cp>최근 Figma와 CSS 모두 간극을 줄이려 노력하고 있습니다:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>Figma Dev Mode (2023): 개발자 친화적 기능\u003C/li>\n\u003Cli>CSS Container Queries: 컴포넌트 기반 반응형\u003C/li>\n\u003Cli>Design Tokens 표준화: W3C 커뮤니티 그룹\u003C/li>\n\u003C/ul>\n\u003Cp>하지만 근본적인 철학의 차이는 여전합니다.\u003C/p>\n\u003Ch3>AI는 답이 될까?\u003C/h3>\n\u003Cp>GPT-4V 같은 AI가 디자인을 코드로 변환할 수 있지만:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>디자인 시스템을 이해하지 못함\u003C/li>\n\u003Cli>일회성 코드 생성\u003C/li>\n\u003Cli>유지보수 불가능\u003C/li>\n\u003C/ul>\n\u003Cp>결국 사람이 이해하고 협업할 수 있는 시스템이 필요합니다.\u003C/p>\n\u003Ch2>AdorableCSS가 만드는 변화\u003C/h2>\n\u003Ch3>1. Figma 개념을 그대로 코드로\u003C/h3>\n\u003Ch4>Auto Layout → hbox/vbox\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: Horizontal Auto Layout --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;hbox gap(20) p(32)&quot;\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>버튼 1\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>버튼 2\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: Vertical Auto Layout with space-between --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">nav\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;vbox(between) h(full) p(24)&quot;\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>로고\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>메뉴\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>하단 정보\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">nav\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>디자이너가 &quot;Horizontal Auto Layout&quot;이라고 말하면, 개발자는 \u003Ccode class=\"bg(gray-50) c(purple-700) px(xs) py(0.5) r(sm) border(1/gray-200) font(mono) text(sm)\">hbox\u003C/code>를 씁니다. 더 이상 \u003Ccode class=\"bg(gray-50) c(purple-700) px(xs) py(0.5) r(sm) border(1/gray-200) font(mono) text(sm)\">display: flex; flex-direction: row\u003C/code>를 기억할 필요가 없습니다.\u003C/p>\n\u003Ch4>Constraints → layer 시스템\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: 오른쪽 하단 고정 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;layer(bottom:20+right:20)&quot;\u003C/span>&gt;\u003C/span>\n  플로팅 버튼\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: 중앙 정렬 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;layer(center)&quot;\u003C/span>&gt;\u003C/span>\n  모달 창\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: 전체 화면 덮기 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;layer(fill)&quot;\u003C/span>&gt;\u003C/span>\n  오버레이\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>Figma의 Constraints를 직관적으로 표현합니다. \u003Ccode class=\"bg(gray-50) c(purple-700) px(xs) py(0.5) r(sm) border(1/gray-200) font(mono) text(sm)\">position: absolute\u003C/code>와 복잡한 계산 대신, 의도를 그대로 코드로 옮깁니다.\u003C/p>\n\u003Ch4>Fill/Hug → w/h 시스템\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: Fill container --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;w(fill)&quot;\u003C/span>&gt;\u003C/span>전체 너비\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: Hug contents --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;w(hug)&quot;\u003C/span>&gt;\u003C/span>내용만큼\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- Figma: Fixed + Fill --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;hbox&quot;\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">aside\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;w(240)&quot;\u003C/span>&gt;\u003C/span>고정 너비\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">aside\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">main\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;w(fill)&quot;\u003C/span>&gt;\u003C/span>나머지 채우기\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">main\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch3>2. 디자인 토큰의 완벽한 동기화\u003C/h3>\n\u003Ch4>색상 시스템\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma Variables와 1:1 매칭 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;bg(surface-primary) c(text-primary)&quot;\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">h1\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;c(text-heading)&quot;\u003C/span>&gt;\u003C/span>제목\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">h1\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">p\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;c(text-body)&quot;\u003C/span>&gt;\u003C/span>본문 내용\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">p\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- Semantic colors --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;bg(action-primary) c(white)&quot;\u003C/span>&gt;\u003C/span>\n  주요 액션\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;bg(feedback-error) c(white)&quot;\u003C/span>&gt;\u003C/span>\n  오류 메시지\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>Figma의 Variable 이름을 그대로 사용합니다. 디자이너가 색상을 변경하면, 토큰만 업데이트하면 됩니다.\u003C/p>\n\u003Ch4>간격 시스템\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma의 8px 그리드 시스템 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;p(xs)&quot;\u003C/span>&gt;\u003C/span>    \u003Cspan class=\"hljs-comment\">&lt;!-- 8px --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;p(sm)&quot;\u003C/span>&gt;\u003C/span>    \u003Cspan class=\"hljs-comment\">&lt;!-- 16px --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;p(md)&quot;\u003C/span>&gt;\u003C/span>    \u003Cspan class=\"hljs-comment\">&lt;!-- 24px --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;p(lg)&quot;\u003C/span>&gt;\u003C/span>    \u003Cspan class=\"hljs-comment\">&lt;!-- 32px --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;p(xl)&quot;\u003C/span>&gt;\u003C/span>    \u003Cspan class=\"hljs-comment\">&lt;!-- 48px --&gt;\u003C/span>\n\n\u003Cspan class=\"hljs-comment\">&lt;!-- 또는 직접 값 사용 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;gap(20) p(40)&quot;\u003C/span>&gt;\u003C/span>  \u003Cspan class=\"hljs-comment\">&lt;!-- 디자이너가 말한 그대로 --&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch3>3. 컴포넌트의 진정한 재사용\u003C/h3>\n\u003Ch4>Figma Component = Code Component\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-javascript\">\u003Cspan class=\"hljs-comment\">// Figma의 Button 컴포넌트를 그대로 코드로\u003C/span>\n\u003Cspan class=\"hljs-keyword\">const\u003C/span> \u003Cspan class=\"hljs-title class_\">Button\u003C/span> = \u003Cspan class=\"hljs-title function_\">defineComponent\u003C/span>({\n  \u003Cspan class=\"hljs-comment\">// Figma의 Variants\u003C/span>\n  \u003Cspan class=\"hljs-attr\">variants\u003C/span>: {\n    \u003Cspan class=\"hljs-attr\">primary\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;bg(primary) c(white)&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-attr\">secondary\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;bg(white) c(primary) border(1/primary)&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-attr\">ghost\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;bg(transparent) c(primary)&#x27;\u003C/span>\n  },\n  \n  \u003Cspan class=\"hljs-comment\">// Figma의 Sizes\u003C/span>\n  \u003Cspan class=\"hljs-attr\">sizes\u003C/span>: {\n    \u003Cspan class=\"hljs-attr\">sm\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;h(32) px(12) text(sm)&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-attr\">md\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;h(40) px(16) text(base)&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-attr\">lg\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;h(48) px(20) text(lg)&#x27;\u003C/span>\n  },\n  \n  \u003Cspan class=\"hljs-comment\">// Figma의 States\u003C/span>\n  \u003Cspan class=\"hljs-attr\">states\u003C/span>: {\n    \u003Cspan class=\"hljs-attr\">hover\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;brightness(1.1)&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-attr\">pressed\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;scale(0.98)&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-attr\">disabled\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;opacity(0.5) cursor(not-allowed)&#x27;\u003C/span>\n  }\n});\n\u003C/code>\u003C/pre>\n\u003Cp>사용할 때:\u003C/p>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Figma에서 선택하듯이 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;btn(primary/lg)&quot;\u003C/span>&gt;\u003C/span>큰 주요 버튼\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">button\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;btn(ghost/sm)&quot;\u003C/span>&gt;\u003C/span>작은 고스트 버튼\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">button\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch3>4. 반응형의 직관적 구현\u003C/h3>\n\u003Ch4>Figma의 Breakpoint를 그대로\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- Mobile First --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;\n  grid(1)           /* 모바일: 1열 */\n  md:grid(2)        /* 태블릿: 2열 */\n  lg:grid(3)        /* 데스크탑: 3열 */\n  gap(16)\n  md:gap(24)\n  lg:gap(32)\n&quot;\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch4>컨테이너 쿼리로 컴포넌트 반응형\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">article\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;container&quot;\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;\n    @sm:hbox          /* 컨테이너가 작으면 세로 */\n    @lg:vbox          /* 컨테이너가 크면 가로 */\n  &quot;\u003C/span>&gt;\u003C/span>\n    \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">img\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;w(full) @lg:w(300)&quot;\u003C/span> /&gt;\u003C/span>\n    \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;p(16) @lg:p(32)&quot;\u003C/span>&gt;\u003C/span>\n      \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">h2\u003C/span>&gt;\u003C/span>제목\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">h2\u003C/span>&gt;\u003C/span>\n      \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">p\u003C/span>&gt;\u003C/span>내용\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">p\u003C/span>&gt;\u003C/span>\n    \u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">div\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">article\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch3>5. 실제 워크플로우의 변화\u003C/h3>\n\u003Ch4>Before: 번역과 해석\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-text\">1. 디자이너: Figma에서 디자인\n2. 개발자: 디자인 분석\n3. 개발자: CSS 속성 조합 고민\n4. 개발자: 구현\n5. 디자이너: &quot;뭔가 다른데...&quot;\n6. 반복...\n\u003C/code>\u003C/pre>\n\u003Ch4>After: 직접 소통\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-text\">1. 디자이너: Figma에서 디자인\n2. 디자이너: &quot;hbox gap(20) p(32)로 만들어주세요&quot;\n3. 개발자: 그대로 구현\n4. 완료\n\u003C/code>\u003C/pre>\n\u003Ch3>6. 디버깅과 수정의 단순화\u003C/h3>\n\u003Ch4>문제 발생 시\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- 디자이너: &quot;간격이 너무 좁아요&quot; --&gt;\u003C/span>\n\u003Cspan class=\"hljs-comment\">&lt;!-- Before: CSS 파일 찾아서 어떤 속성인지 분석 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-comment\">&lt;!-- After: --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">div\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;hbox gap(20)&quot;\u003C/span>&gt;\u003C/span>  \u003Cspan class=\"hljs-comment\">&lt;!-- gap(32)로 바꾸면 끝 --&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch4>실시간 협업\u003C/h4>\n\n  \u003Cpre>\u003Ccode class=\"hljs language-html\">\u003Cspan class=\"hljs-comment\">&lt;!-- 디자이너가 직접 코드 리뷰 가능 --&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">section\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;vbox gap(48) py(80)&quot;\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-comment\">&lt;!-- 디자이너: &quot;여기 gap은 32가 맞아요&quot; --&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">h1\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;heading(xl)&quot;\u003C/span>&gt;\u003C/span>제목\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">h1\u003C/span>&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;\u003Cspan class=\"hljs-name\">p\u003C/span> \u003Cspan class=\"hljs-attr\">class\u003C/span>=\u003Cspan class=\"hljs-string\">&quot;text(body) c(text-secondary)&quot;\u003C/span>&gt;\u003C/span>\n    \u003Cspan class=\"hljs-comment\">&lt;!-- 디자이너: &quot;text-muted로 바꿔주세요&quot; --&gt;\u003C/span>\n  \u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">p\u003C/span>&gt;\u003C/span>\n\u003Cspan class=\"hljs-tag\">&lt;/\u003Cspan class=\"hljs-name\">section\u003C/span>&gt;\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Ch2>결론: 같은 언어로 말하기\u003C/h2>\n\u003Cp>디자이너와 개발자가 다른 언어를 사용하는 것은 역사적 배경과 도구의 한계 때문입니다. 하지만 이는 극복 가능한 문제입니다.\u003C/p>\n\u003Cp>AdorableCSS는 단순히 새로운 CSS 프레임워크가 아닙니다. \u003Cstrong>디자인과 개발 사이의 언어 장벽을 없애는 커뮤니케이션 시스템\u003C/strong>입니다.\u003C/p>\n\u003Cp>더 이상 번역하지 마세요. 같은 언어로 말하세요.\u003C/p>\n\u003Chr>\n\u003Ch2>다음 단계\u003C/h2>\n\u003Cp>이 철학이 구체적으로 어떻게 구현되는지 알아보려면:\u003C/p>\n\u003Cul class=\"list(disc) pl(xl) my(lg)\">\u003Cli>\u003Ca href=\"/docs/overview\"  class=\"c(blue-600) underline decoration(blue-200) hover:decoration(blue-500) transition(all/150ms)\">Overview\u003C/a> - AdorableCSS의 핵심 개념\u003C/li>\n\u003Cli>\u003Ca href=\"/docs/getting-started\"  class=\"c(blue-600) underline decoration(blue-200) hover:decoration(blue-500) transition(all/150ms)\">Getting Started\u003C/a> - 실제 사용 방법\u003C/li>\n\u003C/ul>\n",{},"\n      /* Highlight.js Light Theme inspired by GitHub */\n      .hljs { background: rgb(249 250 251); color: #24292e; }\n      .hljs-comment, .hljs-quote { color: #6a737d; }\n      .hljs-keyword, .hljs-selector-tag, .hljs-literal { color: #d73a49; }\n      .hljs-string { color: #032f62; }\n      .hljs-number { color: #005cc5; }\n      .hljs-variable, .hljs-template-variable, .hljs-attr { color: #e36209; }\n      .hljs-name, .hljs-selector-class, .hljs-selector-id { color: #22863a; }\n      .hljs-title, .hljs-function { color: #6f42c1; }\n      .hljs-built_in { color: #005cc5; }\n      .hljs-params { color: #24292e; }\n      .hljs-meta { color: #005cc5; }\n      .hljs-emphasis { font-style: italic; }\n      .hljs-strong { font-weight: bold; }\n      .hljs-deletion { color: #b31d28; background-color: #ffeef0; }\n      .hljs-addition { color: #22863a; background-color: #f0fff4; }\n      \n      /* Code blocks */\n      pre { \n        background-color: rgb(249 250 251);\n        border: 1px solid rgb(229 231 235);\n      }\n      \n      /* Copy button */\n      .copy-btn {\n        background-color: rgb(243 244 246);\n        border: 1px solid rgb(209 213 219);\n        color: rgb(55 65 81);\n      }\n      .copy-btn:hover {\n        background-color: rgb(229 231 235);\n      }\n    "],"uses":{"params":["slug"]}}]}
