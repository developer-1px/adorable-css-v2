# Bridging Design and Code: The Figma-AdorableCSS Integration

<Info>
This article explores how AdorableCSS creates a seamless bridge between Figma designs and production code, enabling true design-to-code workflows.
</Info>

## The Design-Code Gap

Every frontend developer knows the pain: you receive a beautiful Figma design, and then spend hours translating it to CSS. The mental models are different:

**Figma thinks in:**
- Auto Layout (Horizontal/Vertical)
- Constraints (Hug/Fill)
- Layers and positioning
- Design tokens

**CSS thinks in:**
- Flexbox/Grid properties
- Width/Height values
- Position/Transform
- Custom properties

AdorableCSS eliminates this translation step by speaking Figma's language directly.

## Figma Mental Model in CSS

### Auto Layout → hbox/vbox

```typescript
// Figma: Horizontal Auto Layout
// AdorableCSS:
<div class="hbox gap(16) p(24)">

// Figma: Vertical Auto Layout with alignment
// AdorableCSS:
<div class="vbox(middle) gap(8)">
```

### Constraints → Sizing System

```typescript
// Figma: Width = Fill container
<div class="w(fill)">

// Figma: Width = Hug contents  
<div class="w(hug)">

// Figma: Fixed width with min/max constraints
<div class="w(300..500)">
```

### Layers → Positioning

```typescript
// Figma: Layer with top-left constraints
<div class="layer(top:20+left:30)">

// Figma: Centered layer
<div class="layer(center)">

// Figma: Layer with mixed constraints
<div class="layer(top+x-center)">
```

## The Figma Plugin Architecture

### 1. Design Analysis

The plugin analyzes Figma nodes to extract styling information:

```typescript
interface FigmaNode {
  type: 'FRAME' | 'TEXT' | 'RECTANGLE';
  layoutMode?: 'HORIZONTAL' | 'VERTICAL' | 'NONE';
  primaryAxisAlignItems?: 'MIN' | 'CENTER' | 'MAX' | 'SPACE_BETWEEN';
  counterAxisAlignItems?: 'MIN' | 'CENTER' | 'MAX';
  paddingLeft?: number;
  paddingRight?: number;
  paddingTop?: number;
  paddingBottom?: number;
  itemSpacing?: number;
  fills?: Paint[];
  strokes?: Paint[];
  effects?: Effect[];
}

function analyzeNode(node: FigmaNode): StyleInfo {
  const styles: StyleInfo = {};
  
  // Auto Layout analysis
  if (node.layoutMode === 'HORIZONTAL') {
    styles.layout = 'hbox';
    styles.alignment = mapAlignment(
      node.primaryAxisAlignItems,
      node.counterAxisAlignItems
    );
  } else if (node.layoutMode === 'VERTICAL') {
    styles.layout = 'vbox';
    styles.alignment = mapAlignment(
      node.primaryAxisAlignItems,
      node.counterAxisAlignItems
    );
  }
  
  // Spacing analysis
  if (node.itemSpacing) {
    styles.gap = node.itemSpacing;
  }
  
  // Padding analysis
  const padding = extractPadding(node);
  if (padding) {
    styles.padding = padding;
  }
  
  return styles;
}
```

### 2. Code Generation

Convert analyzed styles to AdorableCSS utilities:

```typescript
function generateAdorableCSS(styles: StyleInfo): string {
  const classes: string[] = [];
  
  // Layout
  if (styles.layout) {
    const alignment = styles.alignment 
      ? `(${styles.alignment})` 
      : '';
    classes.push(`${styles.layout}${alignment}`);
  }
  
  // Gap
  if (styles.gap) {
    classes.push(`gap(${styles.gap})`);
  }
  
  // Padding
  if (styles.padding) {
    if (typeof styles.padding === 'number') {
      classes.push(`p(${styles.padding})`);
    } else {
      const { top, right, bottom, left } = styles.padding;
      if (top === bottom && left === right) {
        classes.push(`p(${top}/${left})`);
      } else {
        classes.push(`pt(${top}) pr(${right}) pb(${bottom}) pl(${left})`);
      }
    }
  }
  
  // Colors
  if (styles.fill) {
    classes.push(`bg(${colorToAdorable(styles.fill)})`);
  }
  
  if (styles.textColor) {
    classes.push(`c(${colorToAdorable(styles.textColor)})`);
  }
  
  return classes.join(' ');
}
```

### 3. Smart Mappings

The plugin includes intelligent mappings for Figma concepts:

```typescript
// Alignment mapping
function mapAlignment(primary: string, counter: string): string {
  const alignmentMap = {
    'MIN+MIN': 'start',
    'MIN+CENTER': 'middle+start',
    'CENTER+CENTER': 'middle',
    'MAX+MAX': 'end',
    'SPACE_BETWEEN+CENTER': 'middle+between'
  };
  
  return alignmentMap[`${primary}+${counter}`] || '';
}

// Color mapping with design tokens
function colorToAdorable(paint: Paint): string {
  // Check if it's a design token
  if (paint.boundVariables?.color) {
    const token = resolveToken(paint.boundVariables.color);
    return token; // e.g., "primary-500"
  }
  
  // Convert color to closest token or value
  if (paint.type === 'SOLID') {
    const { r, g, b, a } = paint.color;
    const hex = rgbToHex(r, g, b);
    
    // Try to match with design tokens
    const token = findClosestToken(hex);
    if (token) return token;
    
    // Return with alpha if needed
    return a < 1 ? `${hex}.${Math.round(a * 10) / 10}` : hex;
  }
  
  // Handle gradients
  if (paint.type === 'GRADIENT_LINEAR') {
    return generateGradient(paint);
  }
}
```

## Advanced Features

### 1. Component Detection

The plugin recognizes Figma components and generates appropriate AdorableCSS utilities:

```typescript
function detectComponent(node: FigmaNode): ComponentType | null {
  // Button detection
  if (
    node.type === 'FRAME' &&
    node.layoutMode === 'HORIZONTAL' &&
    hasTextChild(node) &&
    node.fills?.length > 0 &&
    node.cornerRadius > 0
  ) {
    return {
      type: 'BUTTON',
      variant: detectButtonVariant(node),
      size: detectButtonSize(node)
    };
  }
  
  // Card detection
  if (
    node.type === 'FRAME' &&
    node.effects?.some(e => e.type === 'DROP_SHADOW') &&
    node.cornerRadius > 0 &&
    node.fills?.[0]?.color
  ) {
    return {
      type: 'CARD',
      variant: detectCardVariant(node)
    };
  }
  
  return null;
}

// Generate component utilities
function generateComponentClass(component: ComponentType): string {
  switch (component.type) {
    case 'BUTTON':
      return `btn(${component.variant}/${component.size})`;
    case 'CARD':
      return `card(${component.variant})`;
    default:
      return '';
  }
}
```

### 2. Responsive Design

Handle Figma's responsive constraints:

```typescript
interface Constraints {
  horizontal: 'MIN' | 'CENTER' | 'MAX' | 'STRETCH' | 'SCALE';
  vertical: 'MIN' | 'CENTER' | 'MAX' | 'STRETCH' | 'SCALE';
}

function generateResponsiveClasses(
  node: FigmaNode,
  constraints: Constraints
): string[] {
  const classes: string[] = [];
  
  // Width constraints
  switch (constraints.horizontal) {
    case 'STRETCH':
      classes.push('w(fill)');
      break;
    case 'SCALE':
      classes.push(`w(${node.width}..)`);
      break;
    default:
      classes.push(`w(${node.width})`);
  }
  
  // Position constraints
  if (constraints.horizontal === 'CENTER') {
    classes.push('mx(auto)');
  }
  
  // Add responsive variants
  if (node.minWidth) {
    classes.push(`sm:w(${node.minWidth}..)`);
  }
  
  return classes;
}
```

### 3. Design Tokens Sync

Bidirectional sync between Figma variables and CSS:

```typescript
// Extract design tokens from Figma
async function extractTokens(file: FileNode): Promise<DesignTokens> {
  const tokens: DesignTokens = {
    colors: {},
    spacing: {},
    typography: {}
  };
  
  // Extract color variables
  const colorVariables = await figma.variables.getLocalVariablesAsync('COLOR');
  for (const variable of colorVariables) {
    const value = await variable.resolveForConsumerAsync(file);
    tokens.colors[variable.name] = rgbToHex(value.r, value.g, value.b);
  }
  
  // Extract spacing variables
  const spacingVariables = await figma.variables.getLocalVariablesAsync('FLOAT');
  for (const variable of spacingVariables) {
    if (variable.name.includes('spacing')) {
      const value = await variable.resolveForConsumerAsync(file);
      tokens.spacing[variable.name] = `${value}px`;
    }
  }
  
  return tokens;
}

// Generate CSS custom properties
function generateCSSTokens(tokens: DesignTokens): string {
  return `
:root {
  /* Colors */
${Object.entries(tokens.colors)
  .map(([name, value]) => `  --${name}: ${value};`)
  .join('\n')}
  
  /* Spacing */
${Object.entries(tokens.spacing)
  .map(([name, value]) => `  --${name}: ${value};`)
  .join('\n')}
}
  `.trim();
}
```

## Real-World Examples

### Example 1: Marketing Hero Section

**Figma Structure:**
```
Frame (Vertical Auto Layout, center aligned)
├─ Heading (64px, bold)
├─ Paragraph (20px, regular)
└─ Button (Horizontal Auto Layout)
```

**Generated AdorableCSS:**
```html
<div class="vbox(middle) gap(32) p(80/20) min-h(100vh)">
  <h1 class="heading(h1/hero) c(gray-900) text(center)">
    Welcome to AdorableCSS
  </h1>
  <p class="font(xl) c(gray-600) text(center) max-w(600)">
    The Figma-first CSS framework that speaks your language
  </p>
  <button class="btn(primary/lg)">
    Get Started
  </button>
</div>
```

### Example 2: Card Grid

**Figma Structure:**
```
Frame (Grid, 3 columns, 24px gap)
├─ Card Component Instance
├─ Card Component Instance
└─ Card Component Instance
```

**Generated AdorableCSS:**
```html
<div class="grid grid-cols(3) gap(24) p(40)">
  <div class="card(elevated) vbox gap(16) p(24)">
    <img class="w(full) h(200) object(cover) r(12)" src="...">
    <h3 class="heading(h3) c(gray-900)">Card Title</h3>
    <p class="c(gray-600)">Card description...</p>
  </div>
  <!-- More cards... -->
</div>
```

## Future Developments

### 1. AI-Assisted Generation

Using AI to improve code generation:

```typescript
async function enhanceWithAI(
  node: FigmaNode,
  context: DesignContext
): Promise<EnhancedClasses> {
  // Analyze design patterns
  const pattern = await detectDesignPattern(node, context);
  
  // Generate semantic classes
  if (pattern.type === 'HERO_SECTION') {
    return {
      wrapper: 'hero-section vbox(middle) gap(xl)',
      semanticHints: ['marketing', 'above-fold', 'cta-focused']
    };
  }
  
  // Suggest accessibility improvements
  const a11y = analyzeAccessibility(node);
  if (a11y.issues.length > 0) {
    return {
      ...baseClasses,
      suggestions: a11y.suggestions
    };
  }
}
```

### 2. Real-time Sync

Live updates between Figma and code:

```typescript
// WebSocket connection for real-time updates
class FigmaSync {
  private ws: WebSocket;
  
  connect() {
    this.ws = new WebSocket('wss://adorable-sync.com');
    
    this.ws.on('figma:update', (event) => {
      const { nodeId, changes } = event;
      
      // Update corresponding code
      const element = document.querySelector(`[data-figma-id="${nodeId}"]`);
      if (element) {
        const newClasses = generateAdorableCSS(changes);
        element.className = newClasses;
      }
    });
  }
  
  // Push code changes back to Figma
  updateFigma(elementId: string, classes: string[]) {
    const styles = parseAdorableCSS(classes);
    this.ws.send({
      type: 'code:update',
      elementId,
      styles
    });
  }
}
```

### 3. Design System Management

Complete design system synchronization:

```typescript
interface DesignSystem {
  name: string;
  version: string;
  tokens: DesignTokens;
  components: ComponentLibrary;
  documentation: Documentation;
}

class DesignSystemManager {
  async syncFromFigma(fileKey: string): Promise<DesignSystem> {
    // Extract complete design system
    const file = await figma.getFileAsync(fileKey);
    
    return {
      name: file.name,
      version: file.version,
      tokens: await extractTokens(file),
      components: await extractComponents(file),
      documentation: await generateDocs(file)
    };
  }
  
  async deployToCode(system: DesignSystem) {
    // Generate token files
    await writeFile('tokens.css', generateCSSTokens(system.tokens));
    
    // Generate component utilities
    await writeFile('components.ts', generateComponentUtilities(system.components));
    
    // Update documentation
    await updateDocs(system.documentation);
  }
}
```

## Conclusion

The Figma-AdorableCSS integration represents a paradigm shift in design-to-code workflows. By speaking the same language as designers and providing intelligent code generation, we're not just building a CSS framework—we're creating a bridge between design and development.

The future of frontend development isn't about developers learning design tools or designers learning code. It's about creating systems that understand both worlds and translate between them seamlessly.

<Warning>
The Figma plugin is currently in beta. Join our [early access program](https://adorablecss.com/figma-beta) to try it out and provide feedback.
</Warning>

---

*Ready to bridge the gap? Install the [Figma plugin](https://figma.com/community/plugin/adorable-css) or explore our [integration docs](https://docs.adorablecss.com/figma).*